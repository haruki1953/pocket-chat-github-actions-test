Vue Router 的行为：
```
    每次进入页面都会重新挂载组件
    本地状态丢失
    滚动位置丢失（除非手写）
    数据需要重新请求（除非你自己缓存）
    表单状态丢失（除非你自己保存）
```
TanStack Router 的行为：
```
    路由节点是持久的
    组件实例可以缓存
    loader 数据缓存
    UI 状态缓存
    滚动位置缓存
    返回页面时完全恢复
```

但 TanStack Router 对于vue项目不成熟，所以我不打算使用其，而是手动实现解决这个问题
```
E:\Project\pocket-chat\vue3\src\stores\router-history\router-history.ts
E:\Project\pocket-chat\vue3\src\stores\router-history\modules\recover-image-select-page.ts
E:\Project\pocket-chat\vue3\src\router.ts
E:\Project\pocket-chat\vue3\src\views\image\ImageSelectPage.vue
E:\Project\pocket-chat\vue3\src\views\image\composables\page-recover.ts
```

帮我为此写一个说明文档，以便团队中的成员理解这个项目

`E:\Project\pocket-chat\vue3\src\stores\router-history\router-history.ts`
```ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { useRoute } from 'vue-router'
import { v4 as uuidv4 } from 'uuid'
import {
  useRecoverChatColModule,
  useRecoverImageSelectPageModule,
} from './modules'

type Route = ReturnType<typeof useRoute>

/** 路由信息栈中每一项的类型 */
export type RouterHistoryEntryType = {
  uuid: string
  name: Route['name']
  path: Route['path']
  fullPath: Route['fullPath']
}

/**
 * 自建路由历史栈，记录路由历史信息，可供每个页面设置自己的数据
 * - 主要用于路由返回时，页面中的数据恢复（返回时保持之前浏览的位置和数据）
 * - 也用于某些页面的顶栏的返回按钮，可判断前一历史是否为当前app（是则可以返回，不是则应转到首页）
 */
export const useRouterHistoryStore = defineStore(
  'pocket-together-router-history',
  () => {
    // 路由历史栈，记录路由历史信息
    const stack = ref<Array<RouterHistoryEntryType>>([])
    // 当前路由的uuid，未初始化等特殊情况时为null
    const currentUuid = ref<string | null>(null)

    /** 当前路由信息 */
    const currentRouterHistoryEntry = computed(() => {
      const find = stack.value.find((i) => i.uuid === currentUuid.value)
      return find
    })
    /** 当前前一个路由信息（用于判断返回，此值为null即代表当前app中没有上一页） */
    const currentPreviousRouterHistoryEntry = computed(() => {
      const findIndex = stack.value.findIndex(
        (i) => i.uuid === currentUuid.value
      )
      if (findIndex === -1) {
        return null
      }
      if (findIndex === 0) {
        return null
      }
      return stack.value[findIndex - 1]
    })

    // 【页面恢复数据】START
    // 各路由页面恢复数据，主要用于路由返回时，页面中的数据恢复（返回时保持之前浏览的位置和数据）

    // 【页面恢复数据 ChatCol 】用于 ChatCol 的页面恢复数据
    const recoverChatColModule = useRecoverChatColModule({
      currentUuid,
    })
    const { pageRecoverDataForChatCol } = recoverChatColModule

    // 【页面恢复数据 ImageSelectPage 】用于 ImageSelectPage 的页面恢复数据
    const recoverImageSelectPageModule = useRecoverImageSelectPageModule({
      currentUuid,
    })
    const { pageRecoverDataForImageSelectPage } = recoverImageSelectPageModule

    // 【页面恢复数据】END

    const route = useRoute()

    /** 在router.afterEach中调用此函数，将检查history.state并控制路由历史栈相关的数据 */
    const routerAfterEachCheckHistoryStateAndControlRouterHistoryStack = () => {
      // 检查 history.state?.routorHistoryUuid 是否存在
      // 存在，说明上次路由改变为返回或前进 {
      //   检查 stack 中是否存在此uuid
      //   存在，是正常的，进行正常的操作 {
      //   将 currentUuid 赋值为 routorHistoryUuid
      //   }
      //   不存在，是不正常的，为了鲁棒性当作路由为push进行一些处理 {
      //   }
      // }
      // 不存在，说明上次路由改变为push {
      // 生成一个的uuid，replaceState将其加入
      // 整理 stack 将 currentUuid 之后的删除（push后这些内容就永远都不会被访问了）
      // 将当前路由信息加入 stack
      // 将 currentUuid 赋值为 routorHistoryUuid
      // }

      // 函数复用封装：push时的处理方法
      const handleRoutorHistoryForRoutorPushFn = (
        newRoutorHistoryUuidUuid: string
      ) => {
        // 整理 stack 将 currentUuid 之后的删除（因为push后这些内容就永远都不会被访问了）
        ;(() => {
          if (currentUuid.value == null) {
            return
          }
          const findIndex = stack.value.findIndex(
            (i) => i.uuid === currentUuid.value
          )
          if (findIndex === -1) {
            return
          }
          stack.value = stack.value.slice(0, findIndex + 1)
        })()
        // 将当前路由信息加入 stack
        stack.value.push({
          uuid: newRoutorHistoryUuidUuid,
          name: route.name,
          path: route.path,
          fullPath: route.fullPath,
        })
        // 将 currentUuid 赋值为 newRoutorHistoryUuidUuid
        currentUuid.value = newRoutorHistoryUuidUuid

        // 【页面恢复数据清理】对于各个路由页面恢复数据进行清理，只保留uuid在stack中存在的（将不可访问的删除）
        // 【页面恢复数据清理 ChatCol 】
        pageRecoverDataForChatCol.value =
          pageRecoverDataForChatCol.value.filter((i) => {
            const find = stack.value.find((item) => item.uuid === i.uuid)
            if (find != null) {
              return true
            }
            return false
          })
        // 【页面恢复数据清理 ImageSelectPage 】
        pageRecoverDataForImageSelectPage.value =
          pageRecoverDataForImageSelectPage.value.filter((i) => {
            const find = stack.value.find((item) => item.uuid === i.uuid)
            if (find != null) {
              return true
            }
            return false
          })
      }

      const routorHistoryUuid = history.state?.routorHistoryUuid
      // 检查 history.state?.routorHistoryUuid 是否存在
      // 存在，说明上次路由改变为返回或前进
      if (routorHistoryUuid != null && typeof routorHistoryUuid === 'string') {
        const find = stack.value.find((i) => i.uuid === routorHistoryUuid)
        // 检查 stack 中是否存在此uuid
        // 存在，是正常的，进行正常的操作
        if (find != null) {
          // 将 currentUuid 赋值为 routorHistoryUuid
          currentUuid.value = routorHistoryUuid
        }
        // 不存在，是不常见的，当页面刷新时会出现这种情况
        // 因为刷新时history.state不会改变，但前端重新加载让stack重置了
        // 当作路由行为为push进行处理
        else {
          handleRoutorHistoryForRoutorPushFn(routorHistoryUuid)
        }
      }
      // 不存在，说明上次路由改变为push
      else {
        // 生成一个的uuid，replaceState将其加入（设置为当前路由的uuid）
        const newRoutorHistoryUuidUuid = uuidv4()
        // 只修改State且保留其中原本存在的值
        history.replaceState(
          { ...history.state, routorHistoryUuid: newRoutorHistoryUuidUuid },
          '',
          location.href
        )
        handleRoutorHistoryForRoutorPushFn(newRoutorHistoryUuidUuid)
      }
    }

    return {
      stack,
      currentUuid,
      currentRouterHistoryEntry,
      currentPreviousRouterHistoryEntry,
      routerAfterEachCheckHistoryStateAndControlRouterHistoryStack,
      ...recoverChatColModule,
      ...recoverImageSelectPageModule,
    }
  }
)

```

`E:\Project\pocket-chat\vue3\src\stores\router-history\modules\recover-image-select-page.ts`
```ts
import type { ImagesResponseWithBaseExpand } from '@/api'
import type { ImageQueryModeMarkType } from '@/views/image/composables'

export type PageRecoverDataForImageSelectPageItemType = {
  uuid: string
  data: {
    imageQueryMode: ImageQueryModeMarkType
    imageQuerySearch: string
    imageQueryPage: number
    imageSelectList: ImagesResponseWithBaseExpand[]
    appMainElScrollbarScrollTop: number | undefined
  }
}

/** ImageSelectPage 所需要的页面恢复数据 */
export const useRecoverImageSelectPageModule = (data: {
  //
  currentUuid: Ref<string | null>
}) => {
  const {
    //
    currentUuid,
  } = data

  // 【页面恢复数据】各路由页面恢复数据，主要用于路由返回时，页面中的数据恢复（返回时保持之前浏览的位置和数据）

  // 【页面恢复数据 ImageSelectPage 】用于 ImageSelectPage 的页面恢复数据
  const pageRecoverDataForImageSelectPage = ref<
    Array<PageRecoverDataForImageSelectPageItemType>
  >([])
  // ImageSelectPage 的页面恢复数据设置方法
  const pageRecoverDataForImageSelectPageItemSetFn = (
    val: PageRecoverDataForImageSelectPageItemType
  ) => {
    // 按uuid查找，找到则更新，找不到则添加
    const find = pageRecoverDataForImageSelectPage.value.find(
      (i) => i.uuid === val.uuid
    )
    if (find != null) {
      find.data = val.data
      return 'update' as const
    } else {
      pageRecoverDataForImageSelectPage.value.push(val)
      return 'push' as const
    }
  }
  // ImageSelectPage 的页面恢复数据获取方法
  const pageRecoverDataForImageSelectPageItemGetFn = (uuid: string) => {
    const find = pageRecoverDataForImageSelectPage.value.find(
      (i) => i.uuid === uuid
    )
    return find
  }
  // 设置当前的 ImageSelectPage 的页面恢复数据
  const currentSetPageRecoverDataForImageSelectPageItem = (
    data: PageRecoverDataForImageSelectPageItemType['data']
  ) => {
    if (currentUuid.value == null) {
      return null
    }
    return pageRecoverDataForImageSelectPageItemSetFn({
      uuid: currentUuid.value,
      data,
    })
  }
  // 获取当前的 ImageSelectPage 的页面恢复数据
  const currentGetPageRecoverDataForImageSelectPageItem = () => {
    if (currentUuid.value == null) {
      return null
    }
    return pageRecoverDataForImageSelectPageItemGetFn(currentUuid.value)
  }

  return {
    //
    pageRecoverDataForImageSelectPage,
    pageRecoverDataForImageSelectPageItemSetFn,
    pageRecoverDataForImageSelectPageItemGetFn,
    currentGetPageRecoverDataForImageSelectPageItem,
    currentSetPageRecoverDataForImageSelectPageItem,
  }
}

```
以这个为例，除此之外还有
`E:\Project\pocket-chat\vue3\src\stores\router-history\modules\recover-chat-col.ts`
逻辑类似，具体内容就省略了
```
  return {
    //
    pageRecoverDataForChatCol,
    pageRecoverDataForChatColItemSetFn,
    pageRecoverDataForChatColItemGetFn,
    currentGetPageRecoverDataForChatColItem,
    currentSetPageRecoverDataForChatColItem,
  }
```

`E:\Project\pocket-chat\vue3\src\router.ts`
```ts
// 自建路由历史栈
router.afterEach(() => {
  const routerHistoryStore = useRouterHistoryStore()
  routerHistoryStore.routerAfterEachCheckHistoryStateAndControlRouterHistoryStack()
})
```

以图片选择页页面恢复为例
`E:\Project\pocket-chat\vue3\src\views\image\ImageSelectPage.vue`
```vue
<script setup lang="ts">
// 页面恢复数据获取
const imageSelectPagePageRecoverDataDesuwa =
  useImageSelectPagePageRecoverDataDesuwa()

// 将传入页面恢复数据，其中的变量将会据此初始化，即可达到页面恢复的效果，如
// E:\Project\pocket-chat\vue3\src\views\image\composables\select-list.ts
// // 图片选择列表
// const imageSelectList = ref<ImagesResponseWithBaseExpand[]>([])
// // 图片选择列表
// // 【根据页面恢复数据初始化】
// if (imageSelectPagePageRecoverData != null) {
//   imageSelectList.value = imageSelectPagePageRecoverData.data.imageSelectList
// }

// 封装 imageQueryMode 这一块（desuwa）
// useImageQueryModeDesuwa
const imageQueryModeDesuwa = useImageQueryModeDesuwa({
  imageSelectPagePageRecoverDataDesuwa,
})

// 封装 imageSelectList 这一块desuwa
// image-select-list
// useImageSelectListDesuwa
const imageSelectListDesuwa = useImageSelectListDesuwa({
  imageSelectPagePageRecoverDataDesuwa,
})

// 页面恢复 滚动恢复
useImageSelectPagePageRecoverScrollTop({
  imageSelectPagePageRecoverDataDesuwa,
  refImagePageImageList,
})

// 页面恢复数据收集 在组件离开时执行
useImageSelectPagePageRecoverDataSetOnLeave({
  imageQueryModeDesuwa,
  imageSelectListDesuwa,
})

// ...
</script>
```

`E:\Project\pocket-chat\vue3\src\views\image\composables\page-recover.ts`
```ts
import { useRouterHistoryStore } from '@/stores'
import type { ImageQueryModeDesuwaType } from './query-mode'
import type { ImageSelectListDesuwaType } from './select-list'
import { injectAppMainElScrollbar, useOnComponentLeave } from '@/composables'
import type { RefImagePageImageListType } from './dependencies'
import { watchUntilSourceCondition } from '@/utils'

/** 页面恢复数据获取 */
export const useImageSelectPagePageRecoverDataDesuwa = () => {
  const routerHistoryStore = useRouterHistoryStore()

  const imageSelectPagePageRecoverData =
    routerHistoryStore.currentGetPageRecoverDataForImageSelectPageItem()

  // imageQueryMode: ImageQueryModeMarkType;
  // imageQuerySearch: string;
  // imageQueryPage: number;
  // 在 useImageQueryModeDesuwa 初始化
  // src\views\image\composables\query-mode.ts

  // imageSelectList: {
  //     ...;
  // }[];
  // 在 useImageSelectListDesuwa 初始化
  // src\views\image\composables\select-list.ts

  // appMainElScrollbarScrollTop: number | undefined;
  // 此为滚动位置，比较特殊，因为高度主要由子组件决定，
  // 其初始化实际要依赖子组件中的值，即等待子组件的数据初始化完毕
  // 子组件将导出其值，然后在ImageSelectPage接收并判断与初始化，并封装
  // 在 useImageSelectPagePageRecoverScrollTop 初始化
  // src\views\image\composables\page-recover.ts
  // src\views\image\ImageSelectPage.vue

  return {
    imageSelectPagePageRecoverData,
  }
}

export type ImageSelectPagePageRecoverDataDesuwaType = ReturnType<
  typeof useImageSelectPagePageRecoverDataDesuwa
>

/** 页面恢复 滚动恢复 */
export const useImageSelectPagePageRecoverScrollTop = (data: {
  imageSelectPagePageRecoverDataDesuwa: ImageSelectPagePageRecoverDataDesuwaType
  refImagePageImageList: RefImagePageImageListType
}) => {
  const { imageSelectPagePageRecoverDataDesuwa, refImagePageImageList } = data

  const {
    // 页面恢复数据
    imageSelectPagePageRecoverData,
  } = imageSelectPagePageRecoverDataDesuwa

  const appMainElScrollbar = injectAppMainElScrollbar()

  // 是否有内容高度
  const isHaveContentHeight = computed(() => {
    if (
      refImagePageImageList.value != null &&
      refImagePageImageList.value.refContentBox != null &&
      refImagePageImageList.value.sizeContentBox.width.value > 0 &&
      refImagePageImageList.value.contentBoxHeigh > 0
    ) {
      return true
    }
    return false
  })

  onMounted(async () => {
    // 无 页面恢复数据 直接返回
    if (imageSelectPagePageRecoverData == null) {
      return
    }
    // 等待有内容高度，有内容高度才能初始化滚动
    await watchUntilSourceCondition(isHaveContentHeight, (val) => val === true)
    await nextTick()
    // 因为子组件内的内容高度有过渡duration-300，所以可能还要再等300ms
    await new Promise((resolve) => setTimeout(resolve, 300))
    appMainElScrollbar.value?.wrapRef?.scrollTo({
      top: imageSelectPagePageRecoverData.data.appMainElScrollbarScrollTop, // 滚动到原先的位置
      behavior: 'smooth', // 平滑
    })
  })
}

/**
 * 页面恢复数据收集
 * onBeforeUnmount
 * onBeforeRouteLeave
 */
export const useImageSelectPagePageRecoverDataSetOnLeave = (data: {
  //
  imageQueryModeDesuwa: ImageQueryModeDesuwaType
  imageSelectListDesuwa: ImageSelectListDesuwaType
}) => {
  const {
    //
    imageQueryModeDesuwa,
    imageSelectListDesuwa,
  } = data

  const {
    //
    imageQueryMode,
    imageQuerySearch,
    imageQueryPage,
  } = imageQueryModeDesuwa

  const {
    //
    imageSelectList,
  } = imageSelectListDesuwa

  const appMainElScrollbar = injectAppMainElScrollbar()

  const routerHistoryStore = useRouterHistoryStore()

  const imageSelectPagePageRecoverDataSet = () => {
    routerHistoryStore.currentSetPageRecoverDataForImageSelectPageItem({
      imageQueryMode: imageQueryMode.value,
      imageQuerySearch: imageQuerySearch.value,
      imageQueryPage: imageQueryPage.value,
      imageSelectList: imageSelectList.value,
      appMainElScrollbarScrollTop: appMainElScrollbar.value?.wrapRef?.scrollTop,
    })
  }

  // 在组件离开时执行 页面恢复数据收集
  useOnComponentLeave(imageSelectPagePageRecoverDataSet)
}

```

`E:\Project\pocket-chat\vue3\src\composables\lifecycle.ts`
```ts
import { onBeforeUnmount } from 'vue'
import { onBeforeRouteLeave } from 'vue-router'

/**
 * 在组件离开时执行回调函数。
 *
 * **包括 onBeforeUnmount 与 onBeforeRouteLeave**
 * ```txt
 * onBeforeUnmount 当组件卸载时触发。
 * onBeforeRouteLeave 当前组件因为路由变化而将被卸载时触发。
 * ```

 * 特点：
 * - 同时监听组件卸载与路由离开
 * - 自动保证回调只执行一次
 *
 * 使用场景：
 * - 页面恢复数据收集（pageRecoverDataSet）
 * - 离开页面前保存状态
 * - 离开组件前清理资源
 *
 * ```txt
 * onBeforeUnmount 有一些问题，有时会在 router.afterEach 之后才执行，这对于自己是不正确的，
 * 而 onBeforeRouteLeave 虽然能确保在 router.afterEach 之前执行，但不会触发于非路由卸载（如 v-if）
 * 所以需要将 onBeforeUnmount 和 beforeRouteLeave结合，同时使用这两个，只要让这两个不会执行两次即可
 * 即因路由卸载时是由 onBeforeRouteLeave 触发所以能确保在 router.afterEach 之前执行
 * 而因非路由卸载（如 v-if）时本身就不会触发router.afterEach，所以此时用onBeforeUnmount是没有问题的
 * ```
 *
 * 使用示例
 * ```ts
 * const pageRecoverDataSet = () => {
 *   routerHistoryStore.currentSetPageRecoverDataForImageSelectPageItem({
 *     imageQueryMode: imageQueryMode.value,
 *     imageQuerySearch: imageQuerySearch.value,
 *     imageQueryPage: imageQueryPage.value,
 *     imageSelectList: imageSelectList.value,
 *     appMainElScrollbarScrollTop: appMainElScrollbar.value?.wrapRef?.scrollTop,
 *   })
 * }
 *
 * useOnComponentLeave(pageRecoverDataSet)
 * ```
 *
 * @param callback 要在组件离开时执行的函数
 */
export function useOnComponentLeave(callback: () => void) {
  let hasRun = false

  const runOnce = () => {
    if (hasRun) return
    hasRun = true
    callback()
  }

  onBeforeUnmount(runOnce)
  onBeforeRouteLeave(runOnce)
}

```

帮我为此写一个说明文档
