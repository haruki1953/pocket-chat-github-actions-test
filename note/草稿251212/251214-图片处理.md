```
大图长宽之和 <= 4000
小图长宽之和 <= 1400
图片质量 90

格式 webp ，如果生成失败再用 jpg

src/utils/ （'@/utils'） 中有这几个函数可以用

// 从文件中加载图片
export function imageLoadImageFromFileService(
  // import type { UploadFile, UploadUserFile } from 'element-plus'
  uploadFile: UploadFile | UploadUserFile
): Promise<HTMLImageElement>

// HTMLImageElement 转 HTMLCanvasElement
export function imageElementToCanvasService(
  img: HTMLImageElement
): HTMLCanvasElement

// 按指定倍数缩放图片
export function imageScaleImageService(
  element: HTMLImageElement | HTMLCanvasElement,
  scaleFactor: number
): HTMLCanvasElement

/**
 * 将 HTMLCanvasElement 转换为 Blob
 * @param canvas HTMLCanvasElement
 * @param type 输出的 MIME 类型: "image/png" | "image/jpeg" | "image/webp"
 * @param quality 输出质量 (0~1)，仅在 JPEG/WebP 时有效
 * @returns Promise<Blob>
 */
export const imageCanvasToBlobService = (
  canvas: HTMLCanvasElement,
  type: 'image/png' | 'image/jpeg' | 'image/webp' = 'image/jpeg',
  quality?: number
): Promise<Blob>

/**
 * 将 Blob 对象转换为 File 对象，同时根据其 MIME 类型自动补全文件扩展名。
 *
 * 当传入的 fileName 不包含扩展名时，会依据 MIME 类型自动添加正确的后缀，
 * 例如 "avatar" + image/png → "avatar.png"，以提升兼容性与可识别性。
 *
 * @param {Blob} blob - 要转换的 Blob 数据对象，例如文本、图片、二进制流等。
 * @param {string} fileName - 原始文件名（不含扩展名），如 "report"、"avatar" 等。
 * @returns {File} 封装后的 File 对象，具备 MIME 类型与最后修改时间属性。
 *
 * @example
 * const blob = new Blob(['hello'], { type: 'text/plain' });
 * const file = blobToFile(blob, 'greeting'); // 生成 greeting.txt
 */
export const blobToFile = (blob: Blob, fileName: string): File 
```

帮我写文件处理函数
```
export const uploadImageProcessUtil = () => {}
要有jsdoc

参数：
UploadFile
大图长宽之和配置值
小图长宽之和配置值
图片格式 'image/png' | 'image/jpeg' | 'image/webp'
图片质量 0 到 1 之间
图片失败再处理格式
图片失败再处理质量
（参数中的配置值建议合并为一个对象options，如 (uploadfile: UploadFile, options: { ... }) => {}）

处理
将文件处理，处理为一张大图和一张小图
如果图片文件，长宽之和本来就小于等于 大图长宽之和配置值 ，则就按原本尺寸处理大图
如果图片文件，长宽之和本来就小于等于 小图长宽之和配置值 ，则就按原本尺寸处理小图
图片应处理为File，文件名为 image

返回
image 大图图片
imageWidth 大图图片宽度
imageHeight 大图图片高度
imageSmall 小图图片
imageSmallWidth 小图图片宽度
imageSmallHeight 小图图片高度
```